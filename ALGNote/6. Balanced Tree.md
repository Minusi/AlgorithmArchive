﻿﻿﻿﻿﻿﻿﻿﻿﻿﻿﻿﻿﻿﻿﻿  ##균형잡힌트리(Balanced Tree)---    __레드블랙트리(Red-Black Tree)__- BST는 최악의 경우 O(h) = O(n)이며, 랜덤 순열이 입력으로 들어왔을 때 최악의 경우를 만날 확률은 적지만, 일반적인 상황에서 정렬된 데이터가 입력으로 들어올 확률이 있다는 것을 배제할 수 없음.- 이진탐색트리의 일종- 균형잡힌 트리 : 높이가 O(log<sub>2</sub>n)- SEARCH, INSERT, DELETE 연산을 최악의 경우에도 O(log<sub>2</sub>n) 시간에 지원　  __특징__- 각 노드는 하나의 키(key), 왼쪽자식(left), 오른쪽자식(right), 그리고 부모노드(p)의 주소를 저장- 자식노드가 존재하지 않을 경우 NIL 노드라고 부르는 특수한 노드가 있다고 가정- 따라서 모든 리프노드는 nil노드- 루트의 부모도 nil노드라고 가정- 노드들은 내부노드와 NIL노드로 분류　  __정의__  : 다음의 조건을 만족하는 이진탐색트리- 각 노드는 red 혹은 black- 루트노드는 black- 모든 리프노드(즉, NIL노드)는 black- __red 노드의 자식노드들은 전부 black__ (즉, red노드는 연속되어 등장하지 않음)- 모든 노드에 대해서 그 노드로부터 자손인 리프노드에 이르는 모든 경로에는 __동일한 개수의 black노드가 존재__　  __레드-블랙 트리의 높이__- 노드 x의 높이 h(x)는 자신으로부터 리프노드까지의 가장 긴 경로에 포함된 에지의 개수- 노드 x의 블랙-높이 bh(x)는 x로부터 리프노드까지의 경로상의 블랙노드 개수 (노드 x 자신은 미포함)- 높이가 h인 노드의 블랙-높이는 bh>=h/ (조건 4에 의해 레드노드가 연속될 수 없으므로)- 노드 x를 루트로하는 임의의 부트리는 적어도 2^bh(x) -1개의 내부노드를 포함한다 (수학적 귀납법)　  　  !__이진 트리의 표현__- 연결구조(Linked Structure) 표현 : 각 노드에 하나의 데이터 필드와 왼쪽 자식(left), 오른쪽 자식(right), 그리고 부모노드(p)의 주소를 저장 ( 부모노드의 주소는 반드시 필요한 경우가 아니면 보통 생략함 )  　  __이진 트리의 순회(traversal)__  - 순회 : 이진 트리의 모든 노드를 방문하는 일- 중순위(indorder) 순회 : 트리의 왼쪽 서브트리를 순회하고, 루트를 순회하고, 오른쪽 서브트리를 순회하는 방식- 선순위(preorder) 순회 : - 후순위(postorder) 순회- 레벨오더(level-order) 순회　  ```cpp// 중순위 순회INORDER-TREE-WALK(x){	if x != NULL then		INORDER-TREE-WALK(left[x])		print key[x]		INORDER-TREE-WALK(right[x])}// 선순위 순회PREORDER-TREE-WALK(x){	if x != NULL then		print key[x]		PREORDER-TREE-WALK(left[x])		PREORDER-TREE-WALK(right[x])}// 후순위 순회POSTORDER-TREE-WALK(x){	if x != NULL then		POSTORDER-TREE-WALK(left[x])		POSTORDER-TREE-WALK(right[x])		print key[x]}```　  Level-Order 순회는 다른 방법으로 구현된다:- 레벨 순으로 방문, 동일 레벨에서는 왼쪽에서 오른쪽 순서로- 큐(queue)를 이용하여 구현  ```cpp// 레벨 순위 구현LEVEL-ORDER-TREE-TRAVERSAL(){	visit root	Q <- root;	while Q != empty do		v <- dequeue(Q);		visit children of v;		enqueue children of v into Q;}```　  　  　  ###이진검색트리(binary search tree)---Dynamic Set, Dictionary, or Search Structure라고도 불림.- 여러 개의 키(key)를 저장- 다음과 같은 연산들을 지원하는 자료구조 - INSERT - 새로운 키 삽입 - SEARCH - 키 탐색 - DELETE - 키의 삭제  　  __다양한 방법들__| 형식 | 구분 | search | insert | delete |  | --- | --- | --- | --- | --- || 배열 | 정렬 | O(log<sub>2</sub>n) | O(n) | O(n) || 배열 | 정렬x | O(n) | O(1) (worst : O(n)) | O(1) || 연결리스트 | 정렬 | O(n) | O(n) | O(n)|| 연결리스트 | 정렬x | O(n) | O(1) | O(1) |  - 정렬된 혹은 정렬되지 않은 배열 혹은 연결 리스트를 사용할 경우, INSERT, SEARCH, DELETE 중 적어도 하나는 O(n)  - 이진탐색__트리__(Binary Search Tree), 레드-블랙 __트리__, AVL-__트리__ 등의 트리에 기반한 구조들- Direct Address Table, __해쉬__ 테이블 등  　  __검색트리__- Dynamic set을 트리의 형태로 구현- 일반적으로 SEARCH, INSERT, DELETE 연산이 트리의 높이(height)에 비례하는 시간복잡도를 지님  - 이진검색트리(Binary Searhch Tree), 레드-블랙 트리(red-black tree), B-트리 등  　  __이진검색트리(BST)__- 이진 트리- 각 노드에 하나의 키를 저장- 각 노드 v에 대해서 그 노드의 왼쪽 부트리(subtree)에 있는 키들은 key[v]보다 작거나 같고, 오른쪽 부트리에 있는 값은 크거나 같다.```cpp// 이진 트리의 탐색(재귀)// x = 노드 인덱스, k = 키 값TREE-SEARCH(x, k){	if x = NULL or k = key[x]		then return x	if k < key[x] then return TREE-SEARCH(left[x], k)	else then return TREE-SEARCH(right[x], k)}// 이진 트리의 탐색(반복)ITERATIVE-TREE-SEARCH(x,k){	while x != NULL and k != key[x]		do if k < key[x]			then x <- left[x]		else x <- right[x]	return x}```  　  > 시간복잡도 T(n) : O(h), h는 트리의 높이(height)　  __MINUMUM and MAXIMUM__```cpp// 이진 트리의 최소값을 찾는 함수// x : 트리의 인덱스TREE-MINUMUM(x){	while left[x] != NULL		do x <- left[x]	return x}// 이진 트리의 최대값을 찾는 함수// x : 트리의 인덱스TREE-MAXIMUM(x){	while right[x] != NULL		do x <- right[x];	return x}```　  > 시간복잡도 T(n) : O(h), h는 트리의 높이(height)　  __Successor__  {__%NEED_IMAGE%__}- 노드 x의 successor란 key[x]보다 크면서 가장 작은 키를 가진 노드- 모든 키들이 서로 다르다고 가정- Successor의 3가지 경우: - 노드 x의 오른쪽 부트리가 존재할 경우, 오른쪽 부트리의 최솟값 - 오른쪽 부트리가 없는 경우, 어떤 노드 y의 왼쪽 부트리의 최대값이 x가 되는 그런 노드 y가 x의 successor (즉, 무보를 따라 루트까지 올라가면서 처음으로 누군가의 왼쪽 자식이 되는 노드) - 그런 노드 y가 존재하지 않을 경우 successor가 존재하지 않음(즉, x가 최대값)　  ```cpp// 트리의 successor를 구하는 함수TREE-SUCCESSOR(x){	if right[x] != NULL		then return TREE-MINIMUM(right[x])	y <- p[x]							// y에 x의 부모를 대입	while y != NULL and x = right[y]						do x <- y		y <- p[y]	return y```  　 > 시간복잡도 T(n) : O(h), h는 트리의 높이(height)　  __Preedecessor__- 노드 xdml predecessor란 key[x]보다 작으면서 가장 큰 키를 가진 노드- successor와 반대　  __INSERT__```cpp// T : 트리, z : 삽입할 노드TREE-INSERT(T, z){	y <- NULL	x <- root[T]	while x != NULL		do y <- x			if key[z] < key[x]				then x <- left[x]				else x <- right[x]	p[z] <- y	if y = NULL					// Tree가 비어있을 때 경우		then root[T] <- z	else 						// 트리의 끝에 도달하여 NULL이 된 경우		if key[z] < key[y]			// 해당 값을 삽입한다.			then left[y] <- z			else right[y] <- z}```　  __DELETE__- case 1 _ 자식 노드가 없는 경우 : 그냥 삭제- case 2 _ 자식 노드가 1개인 경우 : 자신의 자식노드를 자신의 위치로 변경- case 3 _ 자식 노드가 2개인 경우 : 해당 노드의 successor를 복사하고 successor를 삭제, 이 떄 sucessor의 자식 노드가 있다면 case 2를 적용　  ```cpp// T : 트리, z : 삭제할 값// 이미 탐색은 끝났다고 가정TREE-DELETE(T, z){	// y : 실제로 삭제할 노드	if left[z] = NULL or right[z] = NULL		// 자식이 1개이거나 0개인 경우		then y <- z	else y <- TREE-SUCCESSOR(z)		// 자식이 2개인 경우	// 노드 y를 삭제	// x : y의 자식	if left[y] != NULL		then x <- left[y]	else x <- right[y]					if x != NULL					// x의 부모를 y의 부모로 설정		then p[x] <- p[y]	if p[y] = NULL					// y가 루트인 경우		then root[T] <- x	else						// y의 부모의 자식을 x로 설정		if y = left[p[y]]			then left[p[y]] <- x		else right[p[y]] <- x	if y != z					// delete case 3의 경우		then key[z] <- key[y]		copy y's satellite data into z	return y}```　  > 시간복잡도 T(n) = O(h), h는 트리의 높이(height)　  __BST 정리__- 각종 연산의 시간복잡도 O(h)- 그러나 최악의 경우 트리의 높이 h=O(n)- 균형잡힌(balanced) 트리 (최악의 경우를 피하기 위한 트리) - 레드-블랙 트리 등 - 키의 삽입이나 삭제시 추가로 트리의 균형을 잡아줌으로써 높이를 O(log<sub>2</sub>n)으로 유지　  　  　  ###Quick sort---데이터가 저장된 배열을 절반으로 나누고, 각각을 순환적으로 정렬한 후, 정렬된 하위의 배열을 합쳐 전체를 정렬하는 방식  　  - 분할 : 배열을 다음과 같은 조건이 만족되도록 두 부분으로 나눈다. (pivot을 설정하고 pivot을 기준으로 작은 값과 큰 값의 그룹으로 분할)- 정복 : 각 부분을 순환적으로 정렬한다.- 합병 : nothing to do( 정복의 결과로 이미 정렬된 상태 )　  ```cpp// 재귀를 사용할 때 매개변수를 명시화 해야하므로 p와 r를 추가함.quickSort(A[], p, r){	if (p<r) then	{		q = partition(A, p, r);		// 분할 (r이 pivot)		quickSort(A, p, q-1);		// 왼쪽 부분배열 정렬		quickSort(A, a+1, r);		// 오른쪽 부분배열 정렬	}}partition(A, p, r);{	// 배열 A[p...r]의 원소들을 A[r]을 기준으로 양쪽으로 재배치하고 	// A[r]이 자리한 위치를 return 한다.	x <- A[r];	i <- p-1;	for j<-p to r-1		if A[j] <= x then			i <- i+1;			exchange A[i] and A[j];	exchange A[i+1] and A[r];			// 피봇의 위치를 중앙으로 교체	return i+1;}```  　  > 시간복잡도 (최악의 경우, 이미 정렬된 입력 데이터일 때 마지막 원소를 피봇으로 선택하는 경우)  > T(n)  = T(0) + T(n-1) + θ(n)	  // θ(n)은 퀵 소트가 배열 n을 순회하는 데 드는 비용, 여기서는 n-1  >   = T(n-1) + θ(n)>   = T(n-2) + T(n-1) + θ(n-1) + θ(n)  >   ...  >   = θ(1) + θ(2) + ... θ(n-1) + θ(n)  >   = θ(n^2)  >  　  > 　   > 시간복잡도 (최선의 경우, 항상 절반으로 분할되는 경우)> T(n) = 2T(n/2) + θ(n)>   = θ(n log<sub>2</sub>n)　  　  　  