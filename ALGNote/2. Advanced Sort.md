﻿﻿﻿﻿﻿﻿﻿﻿﻿## 분할정복법---문제의 사례를 2개 이상의 더 작은 사례로 나누고, 나눈 작은 사례의 해답을 얻을 수있으면 해를 구하고 아니면 더 작은 사례로 나눈다. 해를 구할 수 있을 만큼 충분히 더 작은 사례로 나누어 해결하는 방법  　하향식(Top-down) 접근 방법으로 최상위 사례의 해답은 아래로 내려가면서 작은 사례에 대한 해답을 구함으로써 구하게 된다.　분할정복법의 설계전략- 분할 : 해결하고자 하는 문제를 작은 크기의 동일한 문제들로 분할- 정복 : 각각의 작은 문제를 순환적으로 해결- 합병 : 작은 문제의 해를 합하여(__merge__) 원래 문제에 대한 해를 구함.　  　  　  ###Merge sort---데이터가 저장된 배열을 절반으로 나누고, 각각을 순환적으로 정렬한 후, 정렬된 하위의 배열을 합쳐 전체를 정렬하는 방식  ```cpp// 재귀를 사용할 때 매개변수를 명시화 해야하므로 p와 r를 추가함.mergeSort(A[], p, r)		 //A[p...r]을 정렬한다.{	if (p < r) then	{		q <- (p+q)/2;		// p,q의 중간 지점 계산		mergeSort(A, p, q);	// A[p...q] 정렬		mergeSort(A, q+1, r);	// A[q+1...r] 정렬		merge(A, p, q, r);	// 합병	}}merge(A[], p, q, r){	// 정렬되어 있는 두 배열 A[p...q]와 A[q+1...r]을 합하여	// 정렬된 하나의 배열 A[p...r]을 만든다.}```  　  ```cppvoid merge(int data[], int p, int q, int r){	int i=p, j=q+1, k=p;	int tmp[data.length()];	while( i<=q && j<=r )	{		if (data[i] <= data[j])			tmp[k++] = data[i++];		else			tmp[k++] = data[j++];	}	while (i<=q)		tmp[k++] = data[i++];	while (j<=r)		tmp[k++] = data[j++];	for (int i=p; i<=r; ++i)		data[i] = tmp[i];}```　  　  > 시간복잡도  > T(n) = 0					if n = 1> T(ceil(T(n/2))) + T(floor(T(n/2))) + n	otherwise  > 　  > => T(n) = O( n log<sub>2</sub>n )　  시간복잡도에 n이 포함되는 이유는 merge하는 비용이 계산된 것으로 보면 된다.　  　  　  ###Quick sort---데이터가 저장된 배열을 절반으로 나누고, 각각을 순환적으로 정렬한 후, 정렬된 하위의 배열을 합쳐 전체를 정렬하는 방식  　  - 분할 : 배열을 다음과 같은 조건이 만족되도록 두 부분으로 나눈다. (pivot을 설정하고 pivot을 기준으로 작은 값과 큰 값의 그룹으로 분할)- 정복 : 각 부분을 순환적으로 정렬한다.- 합병 : nothing to do( 정복의 결과로 이미 정렬된 상태 )　  ```cpp// 재귀를 사용할 때 매개변수를 명시화 해야하므로 p와 r를 추가함.quickSort(A[], p, r){	if (p<r) then	{		q = partition(A, p, r);		// 분할 (r이 pivot)		quickSort(A, p, q-1);		// 왼쪽 부분배열 정렬		quickSort(A, a+1, r);		// 오른쪽 부분배열 정렬	}}partition(A, p, r);{	// 배열 A[p...r]의 원소들을 A[r]을 기준으로 양쪽으로 재배치하고 	// A[r]이 자리한 위치를 return 한다.	x <- A[r];	i <- p-1;	for j<-p to r-1		if A[j] <= x then			i <- i+1;			exchange A[i] and A[j];	exchange A[i+1] and A[r];			// 피봇의 위치를 중앙으로 교체	return i+1;}```  　  > 시간복잡도 (최악의 경우, 이미 정렬된 입력 데이터일 때 마지막 원소를 피봇으로 선택하는 경우)  > T(n)  = T(0) + T(n-1) + θ(n)	  // θ(n)은 퀵 소트가 배열 n을 순회하는 데 드는 비용, 여기서는 n-1  >   = T(n-1) + θ(n)>   = T(n-2) + T(n-1) + θ(n-1) + θ(n)  >   ...  >   = θ(1) + θ(2) + ... θ(n-1) + θ(n)  >   = θ(n^2)  >  　  > 　   > 시간복잡도 (최선의 경우, 항상 절반으로 분할되는 경우)> T(n) = 2T(n/2) + θ(n)>   = θ(n log<sub>2</sub>n)　  　  　  ###Balanced Partition---항상 한쪽이 적어도 1/9 이상이 되도록 분할된다면...　  　  　  ###Pivot의 선택  ---첫 번째 값이나 마지막 값을 피봇으로 선택하는 것은 좋은 것이 아니다.  - 이미 정렬된 데이터 혹은 거꾸로 정렬된 데이터가 입력으로 들어오면 최악의 경우  - 현실의 데이터는 랜덤하지 않기 때문에 (거꾸로) 정렬된 데이터가 입력으로 들어올 가능성이 매우 높음  　  Median of Three- 요소의 첫 번째 값과 마지막 값, 그리고 가운데 값 중에서 중간값(median)을 피봇으로 선택하는 방식- 최악의 경우 시간복잡도가 달라지지는 않음Randomized Quicksort- 피봇을 랜덤하게 선택- 최악의 경우에 대한 인스턴스 예는 없지만. 최악의 경우 실행은 여전히 가능하다.　  　  　  ###Heap---- 최악의 경우 시간복잡도 O(nlog<sub>2</sub>n)- Sorts in place - 추가 배열 불필요- 이진 힙(binary heap) 자료구조를 사용　  Heap :- complete binary tree(완전 이진 트리)이면서- heap property(max heap property || min heap property)를 만족해야함.　  Heap의 기본 연산 - MAX-HEAPIFY  - 전체를 힙으로 만드는 것- 트리 전체 모양이 complete binary tree이면서, 왼쪽 부트리(subtree)는 그 자체로 heap이고, 오른쪽 부트리(subtreE)도 그 자체로 heap일 때, 유일하게 루트만이 heap property를 만족하지 않을 때 사용　  MAX-HEAPIFY - recursive version```cpp// A : Heap, i = Heap의 인덱스MAX-HEAPIFY(A, i){	if A[i]에 child가 없으면		return;	k <- i의 자식 중에 가장 큰 값의 인덱스	if A[i] >= A[k]				// 부모가 자식보다 크면 바꿀 필요 없음		return;	exchange A[i] and A[k];	MAX-HEAPIFY(A, k);}```　  MAX-HEAPIFY - iterative version```cpp// A : Heap, i = Heap의 인덱스MAX-HEAPIFY(A, i){	while A[i]의 자식이 없을 때까지		k <- i의 자식 중에 가장 큰 값의 인덱스;		if A[i] >= A[k]			return;		exchange A[i] and A[k];	end.}```　  MAX-HEAPIFY의 시간복잡도> T(n) = θ(log<sub>2</sub>n)　  　  　  ###Heap sort---Heap sort를 사용하기 위해서는 먼저 배열을 Heap으로 만들어야 한다.```cppBUILD-MAX-HEAP(A){	heap-size[A] <- length[A]	for i <- floor( length[A]/2 ) downto 1		do MAX-HEAPIFY(A,i)}```  > 시간복잡도 T(n) = O(n) ( not O(n log<sub>2</sub>n) )　  Heapsort- 주어진 배열을 힙(Heap)으로 만든다.  - 힙에서 최대값(루트)를 마지막 값과 바꾼다.- 힙 크기가 1 줄어든 것으로 간주한다.(즉, 마지막 값은 힙의 일부가 아닌 것으로 간주)- 루트 노드에 대해서 HEAPIFY(1)한다.- 2 ~ 4번을 반복한다.　  ```cppHEARPSORT(A){	BUILD-MAX-HEAP(A)				// O(n)	for i <- heap_size downto 2 do	// n-1 Times		exchange A[1] <-> A[i]		// O(1)		heap_size <- heap_size - 1	// O(1)		MAX-HEAPIFY(A, 1)			// O(log2 n)```　  　  시간복잡도  > T(n) = O( n log<sub>2</sub>n )　  　  　  ###Merge sort---데이터가 저장된 배열을 절반으로 나누고, 각각을 순환적으로 정렬한 후, 정렬된 하위의 배열을 합쳐 전체를 정렬하는 방식  ```cpp// 재귀를 사용할 때 매개변수를 명시화 해야하므로 p와 r를 추가함.mergeSort(A[], p, r)		 //A[p...r]을 정렬한다.{	if (p < r) then	{		q <- (p+q)/2;		// p,q의 중간 지점 계산		mergeSort(A, p, q);	// A[p...q] 정렬		mergeSort(A, q+1, r);	// A[q+1...r] 정렬		merge(A, p, q, r);	// 합병	}}merge(A[], p, q, r){	// 정렬되어 있는 두 배열 A[p...q]와 A[q+1...r]을 합하여	// 정렬된 하나의 배열 A[p...r]을 만든다.}```  　  ```cppvoid merge(int data[], int p, int q, int r){	int i=p, j=q+1, k=p;	int tmp[data.length()];	while( i<=q && j<=r )	{		if (data[i] <= data[j])			tmp[k++] = data[i++];		else			tmp[k++] = data[j++];	}	while (i<=q)		tmp[k++] = data[i++];	while (j<=r)		tmp[k++] = data[j++];	for (int i=p; i<=r; ++i)		data[i] = tmp[i];}```　  　  > 시간복잡도  > T(n) = 0					if n = 1> T(ceil(T(n/2))) + T(floor(T(n/2))) + n	otherwise  > 　  > => T(n) = O( n log<sub>2</sub>n )　  시간복잡도에 n이 포함되는 이유는 merge하는 비용이 계산된 것으로 보면 된다.　  　  　  ###힙의 응용 : 우선순위 큐---최대 우선순위 큐(maximum priority queue)는 다음의 두 가지 연산을 지원하는 자료구조  (최소 우선순위 큐(minimum priority queue)는 EXTRACT-MIN을 지원하는 자료구조)  - INSERT(X) : 새로운 원소 x를 삽입- EXTRACT_MAX() : 최대값을 삭제하고 반환　  MAX HEAP을 이용하여 최대 우선순위 큐를 구현  　  ```cppMAX-HEAP-INSERT(A, key){	heap_size = heap_size + 1;	A[heap_size] = key;	i = heap_size;	while i > 1 and A[Parent(i) < A[i])	{		exchange A[i] <-> A[Parent(i)];		i = Parent(i);	}}```  　  > 시간복잡도 T(n) = O(log<sub>2</sub>n)	// 한 번의 연산마다 도메인 크기가 절반으로 감소하므로　  ```cppHEAP-EXTRACT-MAX(A){	if heap_size[A] < 1		then error "heap underflow"	max <- A[1]	A[1] <- A[heap_size(A)]	heap_size(A) <- heap_size(A) - 1	MAX-HEAPIFY(A,1)	return max