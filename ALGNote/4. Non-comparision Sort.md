﻿##선형시간 정렬 알고리즘---__Counting Sort__- n개의 정수를 정렬(단, 모든 정수는 0에서 k사이의 정수)- ex : n명의 학생들의 시험점수를 정렬하라. (단 모든 점수는 100이하의 양의 정수)- 입력의 범위를 저장하는 카운터 배열(C)를 선언하여 각 인덱스에 알맞는 값이 나온 횟수를 카운팅　```cpp// 적합하지 않은 정렬 알고리즘// primitive 데이터에는 적합할 수 있으나, 대부분의 경우 정렬할 key값들은 레코드의 일부이므로...int A[n];int C[k] = {0, };						// 카운팅 하기 위한 배열 선언for (int i = 1; i <= n; ++i)	C[A[i]]}++;					// A[i]에 나온 값의 수만큼 카운팅for (int s = 1, i = 0; i <= k; ++i){	for (int j = 0; j < C[i]; ++j)	{		A[s++] = i;				// 카운팅 결과를 A 배열에 덮어쓰기	}}```  　  올바른 방법 :- Count 배열을 누적합산배열로 변환- 원 배열을 역순으로 탐색하면서 해당 인덱스의 값을 Count 배열의 값 위치에 저장- 참조된 Count 배열의 값을 -1로 변환- 2-4번 루틴 반복　  ```cpp// n은 배열 크기, k는 키 값의 갯수COUNTING-SORT(A,B,k){	for i <- o to k		do C[i] <- 0			// 초기화	for j <- 1 to length[A]		do C[A[j]] <- C[A[j]] + 1	// Counting	for i <- 1 to k		do C[i] <- C[i] + C[i-1]	// 누적 합산 배열로 변환	for j <- length[A] downto 1		do B[C[A[j]]] <- A[j]		// 새로운 배열에 정렬			C[A[j] <- C[A[j] -1}```  　  > 시간복잡도 T(n) = θ(n+k), 또는 θ(n) if k=O(n)  - k가 클 경우 비실용적- stable 정렬 알고리즘 (입력에 동일한 값이 있을 때 입력에 먼저 나오는 값이 출력에서도 먼저 나온다)이다.　  　  　  ###Radix Sort---- n개의 d자리 정수들  - 가장 낮은 자리수부터 정렬  - 정렬 과정이 stable해야 한다.- 정렬 과정이 stable하므로 낮은 자리수부터 정렬을 하여도 중간과정에서 숫자가 뒤집혀 나올 일이 없음.　  ```cpp// A : 배열, d : 자릿수RADIX-SORT(A, d){	for i <- 1 to d		do use stable sort to sort array A on digit i}```　  > 시간복잡도 T(n) = O(d(n+k)) (단, k가 상수이고 d가 상수이면 O(n)일 수 있다)　  　  　  ###정렬 알고리즘들---|Sort Algorithm | T(n) |  |---------------- | ----- || Bubble sort     | θ(n^2) || Insertion sort  | θ(n^2) || Selection sort | θ(n^2) || Quick sort        | worst : θ(n^2), average : θ(nlog<sub>2</sub>n) || Merge sort       | θ(nlog<sub>2</sub>n) || Heap sort         | θ(nlog<sub>2</sub>n) || Counting sort  | θ(n+k) || Radix sort        | θ(d(n+k)) |