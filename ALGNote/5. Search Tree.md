﻿﻿﻿﻿﻿﻿﻿﻿﻿﻿﻿  ##검색트리(search tree)---    __트리__- 계층적인 구조를 표현 (조직도, 디렉토리와 서브디렉토리 구조, 가계도)- 트리는 노드(node)들과 노드들을 연결하는 링크(link)들로 구성됨- 노드가 N개인 트리는 항상 N-1개의 링크(link)를 가진다- 트리의 루트에서 어떤 노드로 가는 경로는 유일하다. 또한 임의의 두 노드간 경로도 유일하다. ( 같은 노드를 두 번 이상 방문하지 않는다는 조건하에 )　  > 트리 관련 용어 : 루트(root), 부모(parent), 자식(child), 형제(sibling), 리프(leaf), 내부(internal), 조상(ancestor), 자손(descendant), 부트리(subtree), 레벨(level), 높이(height)　__이진 트리(binary tree)__- 이진 트리에서 각 노드는 최대 2개의 자식을 가진다- 각각의 자식 노드는 자신이 부모의 왼쪽 자식인지 오른쪽 자식인지가 지정된다. ( 자식이 1명일 때도 )- 이진 트리 예 : Expression Tree, Huffman Code　  __Full and Complete Binary Trees__- 높이가 h인 full binary tree는 2^h -1개의 노드를 가진다.- 노드가 N개인 full 혹은 complete 이진 트리의 높이는 O(log<sub>2</sub>N)이다. (노드가 N개인 이진트리의 높이는 최악의 경우 N이될 수 있다.)  　  __이진 트리의 표현__- 연결구조(Linked Structure) 표현 : 각 노드에 하나의 데이터 필드와 왼쪽 자식(left), 오른쪽 자식(right), 그리고 부모노드(p)의 주소를 저장 ( 부모노드의 주소는 반드시 필요한 경우가 아니면 보통 생략함 )  　  __이진 트리의 순회(traversal)__  - 순회 : 이진 트리의 모든 노드를 방문하는 일- 중순위(indorder) 순회 : 트리의 왼쪽 서브트리를 순회하고, 루트를 순회하고, 오른쪽 서브트리를 순회하는 방식- 선순위(preorder) 순회 : - 후순위(postorder) 순회- 레벨오더(level-order) 순회　  ```cpp// 중순위 순회INORDER-TREE-WALK(x){	if x != NULL then		INORDER-TREE-WALK(left[x])		print key[x]		INORDER-TREE-WALK(right[x])}// 선순위 순회PREORDER-TREE-WALK(x){	if x != NULL then		print key[x]		PREORDER-TREE-WALK(left[x])		PREORDER-TREE-WALK(right[x])}// 후순위 순회POSTORDER-TREE-WALK(x){	if x != NULL then		POSTORDER-TREE-WALK(left[x])		POSTORDER-TREE-WALK(right[x])		print key[x]}```　  Level-Order 순회는 다른 방법으로 구현된다:- 레벨 순으로 방문, 동일 레벨에서는 왼쪽에서 오른쪽 순서로- 큐(queue)를 이용하여 구현  ```cpp// 레벨 순위 구현LEVEL-ORDER-TREE-TRAVERSAL(){	visit root	Q <- root;	while Q != empty do		v <- dequeue(Q);		visit children of v;		enqueue children of v into Q;}```　  　  　  ###이진검색트리(binary search tree)---Dynamic Set, Dictionary, or Search Structure라고도 불림.- 여러 개의 키(key)를 저장- 다음과 같은 연산들을 지원하는 자료구조 - INSERT - 새로운 키 삽입 - SEARCH - 키 탐색 - DELETE - 키의 삭제  　  __다양한 방법들__| 형식 | 구분 | search | insert | delete |  | --- | --- | --- | --- | --- || 배열 | 정렬 | O(log<sub>2</sub>n) | O(n) | O(n) || 배열 | 정렬x | O(n) | O(1) (worst : O(n)) | O(1) || 연결리스트 | 정렬 | O(n) | O(n) | O(n)|| 연결리스트 | 정렬x | O(n) | O(1) | O(1) |  - 정렬된 혹은 정렬되지 않은 배열 혹은 연결 리스트를 사용할 경우, INSERT, SEARCH, DELETE 중 적어도 하나는 O(n)  - 이진탐색__트리__(Binary Search Tree), 레드-블랙 __트리__, AVL-__트리__ 등의 트리에 기반한 구조들- Direct Address Table, __해쉬__ 테이블 등  　  __검색트리__- Dynamic set을 트리의 형태로 구현- 일반적으로 SEARCH, INSERT, DELETE 연산이 트리의 높이(height)에 비례하는 시간복잡도를 지님  - 이진검색트리(Binary Searhch Tree), 레드-블랙 트리(red-black tree), B-트리 등  　  __이진검색트리(BST)__- 이진 트리- 각 노드에 하나의 키를 저장- 각 노드 v에 대해서 그 노드의 왼쪽 부트리(subtree)에 있는 키들은 key[v]보다 작거나 같고, 오른쪽 부트리에 있는 값은 크거나 같다.```cpp// 이진 트리의 탐색(재귀)// x = 노드 인덱스, k = 키 값TREE-SEARCH(x, k){	if x = NULL or k = key[x]		then return x	if k < key[x] then return TREE-SEARCH(left[x], k)	else then return TREE-SEARCH(right[x], k)}// 이진 트리의 탐색(반복)ITERATIVE-TREE-SEARCH(x,k){	while x != NULL and k != key[x]		do if k < key[x]			then x <- left[x]		else x <- right[x]	return x}```  　  > 시간복잡도 T(n) : O(h), h는 트리의 높이(height)　  __MINUMUM and MAXIMUM__```cpp// 이진 트리의 최소값을 찾는 함수// x : 트리의 인덱스TREE-MINUMUM(x){	while left[x] != NULL		do x <- left[x]	return x}// 이진 트리의 최대값을 찾는 함수// x : 트리의 인덱스TREE-MAXIMUM(x){	while right[x] != NULL		do x <- right[x];	return x}```　  > 시간복잡도 T(n) : O(h), h는 트리의 높이(height)　  __Successor__  {__%NEED_IMAGE%__}- 노드 x의 successor란 key[x]보다 크면서 가장 작은 키를 가진 노드- 모든 키들이 서로 다르다고 가정- Successor의 3가지 경우: - 노드 x의 오른쪽 부트리가 존재할 경우, 오른쪽 부트리의 최솟값 - 오른쪽 부트리가 없는 경우, 어떤 노드 y의 왼쪽 부트리의 최대값이 x가 되는 그런 노드 y가 x의 successor (즉, 무보를 따라 루트까지 올라가면서 처음으로 누군가의 왼쪽 자식이 되는 노드) - 그런 노드 y가 존재하지 않을 경우 successor가 존재하지 않음(즉, x가 최대값)　  ```cpp// 트리의 successor를 구하는 함수TREE-SUCCESSOR(x){	if right[x] != NULL		then return TREE-MINIMUM(right[x])	y <- p[x]							// y에 x의 부모를 대입	while y != NULL and x = right[y]						do x <- y		y <- p[y]	return y```  　 > 시간복잡도 T(n) : O(h), h는 트리의 높이(height)　  __Preedecessor__- 노드 xdml predecessor란 key[x]보다 작으면서 가장 큰 키를 가진 노드- successor와 반대　  __INSERT__```cpp// T : 트리, z : 삽입할 노드TREE-INSERT(T, z){	y <- NULL	x <- root[T]	while x != NULL		do y <- x			if key[z] < key[x]				then x <- left[x]				else x <- right[x]	p[z] <- y	if y = NULL					// Tree가 비어있을 때 경우		then root[T] <- z	else 						// 트리의 끝에 도달하여 NULL이 된 경우		if key[z] < key[y]			// 해당 값을 삽입한다.			then left[y] <- z			else right[y] <- z}```　  __DELETE__- case 1 _ 자식 노드가 없는 경우 : 그냥 삭제- case 2 _ 자식 노드가 1개인 경우 : 자신의 자식노드를 자신의 위치로 변경- case 3 _ 자식 노드가 2개인 경우 : 해당 노드의 successor를 복사하고 successor를 삭제, 이 떄 sucessor의 자식 노드가 있다면 case 2를 적용　  ```cpp// T : 트리, z : 삭제할 값// 이미 탐색은 끝났다고 가정TREE-DELETE(T, z){	// y : 실제로 삭제할 노드	if left[z] = NULL or right[z] = NULL		// 자식이 1개이거나 0개인 경우		then y <- z	else y <- TREE-SUCCESSOR(z)		// 자식이 2개인 경우	// 노드 y를 삭제	// x : y의 자식	if left[y] != NULL		then x <- left[y]	else x <- right[y]					if x != NULL					// x의 부모를 y의 부모로 설정		then p[x] <- p[y]	if p[y] = NULL					// y가 루트인 경우		then root[T] <- x	else						// y의 부모의 자식을 x로 설정		if y = left[p[y]]			then left[p[y]] <- x		else right[p[y]] <- x	if y != z					// delete case 3의 경우		then key[z] <- key[y]		copy y's satellite data into z	return y}```　  > 시간복잡도 T(n) = O(h), h는 트리의 높이(height)　  __BST 정리__- 각종 연산의 시간복잡도 O(h)- 그러나 최악의 경우 트리의 높이 h=O(n)- 균형잡힌(balanced) 트리 (최악의 경우를 피하기 위한 트리) - 레드-블랙 트리 등 - 키의 삽입이나 삭제시 추가로 트리의 균형을 잡아줌으로써 높이를 O(log<sub>2</sub>n)으로 유지　  　  　  ###Quick sort---데이터가 저장된 배열을 절반으로 나누고, 각각을 순환적으로 정렬한 후, 정렬된 하위의 배열을 합쳐 전체를 정렬하는 방식  　  - 분할 : 배열을 다음과 같은 조건이 만족되도록 두 부분으로 나눈다. (pivot을 설정하고 pivot을 기준으로 작은 값과 큰 값의 그룹으로 분할)- 정복 : 각 부분을 순환적으로 정렬한다.- 합병 : nothing to do( 정복의 결과로 이미 정렬된 상태 )　  ```cpp// 재귀를 사용할 때 매개변수를 명시화 해야하므로 p와 r를 추가함.quickSort(A[], p, r){	if (p<r) then	{		q = partition(A, p, r);		// 분할 (r이 pivot)		quickSort(A, p, q-1);		// 왼쪽 부분배열 정렬		quickSort(A, a+1, r);		// 오른쪽 부분배열 정렬	}}partition(A, p, r);{	// 배열 A[p...r]의 원소들을 A[r]을 기준으로 양쪽으로 재배치하고 	// A[r]이 자리한 위치를 return 한다.	x <- A[r];	i <- p-1;	for j<-p to r-1		if A[j] <= x then			i <- i+1;			exchange A[i] and A[j];	exchange A[i+1] and A[r];			// 피봇의 위치를 중앙으로 교체	return i+1;}```  　  > 시간복잡도 (최악의 경우, 이미 정렬된 입력 데이터일 때 마지막 원소를 피봇으로 선택하는 경우)  > T(n)  = T(0) + T(n-1) + θ(n)	  // θ(n)은 퀵 소트가 배열 n을 순회하는 데 드는 비용, 여기서는 n-1  >   = T(n-1) + θ(n)>   = T(n-2) + T(n-1) + θ(n-1) + θ(n)  >   ...  >   = θ(1) + θ(2) + ... θ(n-1) + θ(n)  >   = θ(n^2)  >  　  > 　   > 시간복잡도 (최선의 경우, 항상 절반으로 분할되는 경우)> T(n) = 2T(n/2) + θ(n)>   = θ(n log<sub>2</sub>n)　  　  　  