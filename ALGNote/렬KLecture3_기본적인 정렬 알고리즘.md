## 분할정복법---문제의 사례를 2개 이상의 더 작은 사례로 나누고, 나눈 작은 사례의 해답을 얻을 수있으면 해를 구하고 아니면 더 작은 사례로 나눈다. 해를 구할 수 있을 만큼 충분히 더 작은 사례로 나누어 해결하는 방법  　하향식(Top-down) 접근 방법으로 최상위 사례의 해답은 아래로 내려가면서 작은 사례에 대한 해답을 구함으로써 구하게 된다.　분할정복법의 설계전략- 분할 : 해결하고자 하는 문제를 작은 크기의 동일한 문제들로 분할- 정복 : 각각의 작은 문제를 순환적으로 해결- 합병 : 작은 문제의 해를 합하여(__merge__) 원래 문제에 대한 해를 구함.　	　　###Merge sort---데이터가 저장된 배열을 절반으로 나누고, 각각을 순환적으로 정렬한 후, 정렬된 하위의 배열을 합쳐 전체를 정렬하는 방식  ```cpp// 재귀를 사용할 때 매개변수를 명시화 해야하므로 p와 r를 추가함.mergeSort(A[], p, r)		 //A[p...r]을 정렬한다.{	if (p < r) then	{		q <- (p+q)/2;		// p,q의 중간 지점 계산		mergeSort(A, p, q);	// A[p...q] 정렬		mergeSort(A, q+1, r);	// A[q+1...r] 정렬		merge(A, p, q, r);	// 합병	}}merge(A[], p, q, r){	// 정렬되어 있는 두 배열 A[p...q]와 A[q+1...r]을 합하여	// 정렬된 하나의 배열 A[p...r]을 만든다.}```  　  ```cppvoid merge(int data[], int p, int q, int r){	int i=p, j=q+1, k=p;	int tmp[data.length()];	while( i<=q && j<=r )	{		if (data[i] <= data[j])			tmp[k++] = data[i++];		else			tmp[k++] = data[j++];	}	while (i<=q)		tmp[k++] = data[i++];	while (j<=r)		tmp[k++] = data[j++];	for (int i=p; i<=r; ++i)		data[i] = tmp[i];}```　  　  > 시간복잡도  > T(n) = 0					if n = 1> T(ceil(T(n/2))) + T(floor(T(n/2))) + n	otherwise  > 　  > => T(n) = O( n log<sub>2</sub>n )　  시간복잡도에 n이 포함되는 이유는 merge하는 비용이 계산된 것으로 보면 된다.